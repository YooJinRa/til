# Dynamic Programming(동적계획법 / DP)
- DP, Dynamic Programming(동적 계획법)은 기본적인 아이디어로 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것으로 하나의 문제해결 패러다임

```
function solution(n) {
  let arr = Array(n).fill(0);
  arr[1] = 1;
  arr[2] = 2;

  for(let i=3; i<=n; i++){
    arr[i] = (arr[i-1] + arr[i-2]) % 1234567;
  }
  return arr[n];
}
```

-----

### DP 사용하는 이유
- 일반적인 재귀(Naive Recursion) 방식 또한 DP와 매우 유사 -> 일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산될 수 있다는 것
- DP는 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용

-----

### DP 사용 조건
#### 1) Overlapping Subproblems(겹치는 부분 문제)
- 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능
- DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야 하는데, 해당 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없음

#### 2) Optimal Substructure(최적 부분 구조)
- 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우
- 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일

-----

### 구현방법
#### 1) Bottom-Up 방식
- 아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식
- 메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태 ->  Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식
- Tabulation : Bottom-up일 때는 Memoization을 Tabulation으로 부름 -> 반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 "table-filling" 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 Tabulation이라는 명칭됨


#### 2) Top-Down 방식
- dp[n]의 값을 찾기 위해 위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식
