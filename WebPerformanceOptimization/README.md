# 웹 성능최적화 Web Performace Optimization

## 웹 성능최적화란?

- 성능 최적화는 단순히 각종 비용을 줄이는 측면에서 볼 수 있음(소모하는 리소스 : 메모리 사용량, 처리 시간 등)
- 웹 프론트앤드 환경에서는 각종 파일들을 주고 받으며 화면을 띄우고 화면을 업데이트하는 과정속에서 비용을 소모
- 웹 프론트앤드 성능 개선을 위해서 웹 개발자는 최소한의 데이터로 가장 빠른 시간에 사용자가 불편함을 느끼지 않는 최적의 화면을 띄워야 함
- 성능 최적화를 하게 되면 곧 사용자 경험의 개선으로 이어지고 기업의 실적으로도 이어짐

---

## 성능개선지표

- 현대의 웹 브라우저 환경은 DOM 생성을 최대한 빨리하고 블로킹을 일으키는 복잡한 스크립트 로직은 비동기적으로 처리
- SPA 라이브러리 같은 경우도 상당히 연산이 심하기 때문에 비동기적으로 스크립트가 실행
- 최근의 성능 측정에서는 사용자가 직접 느끼는 부분을 중요시 하기 때문에 다음과 같은 사용자 기준으로 성능을 측정
  - FP(First Paint) : 처음 뭔가 그리기 시작
  - FCP(First Contentful Paint) : 텍스트나 이미지 그리기 시작
  - FMP(First Meaningful Paint) : 의미 있는 데이터 그리기 시작
  - TTI(Time to Interactive) : 사용자가 행동을 취할수 있는 시점
- 같은 혹은 더 빠른 DOMContentLoaded, load 이벤트 시점이라도 사용자는 점차적으로 보이는 화면(optimized rendering)을 더 빠르다고 판단
  <img src="https://velog.velcdn.com/images/ottoyoon98/post/2ed19627-e0a4-4c2e-9340-1157b6f96a19/image.PNG" width="800" />

---

## 프래임워크와 라이브러리 평가

- 모든 프로젝트에 프레임워크와 SPA 라이브러리가 필요로 되는 건 아니고 한번 선택되면 바꾸기 어렵기 때문에 선택을 신중할 필요 있음
- 접근성, 안정성, 프로젝트 적합도, 러닝커브, Document, 관련 생태계 등 많은 고려 필요
- SPA 라이브러리 같은 경우에는 `SSR` 이나 `Pre-rendering` 지원되는지 알아보면 좋음
  - SSR : 서버사이드 렌더링의 약자로 서버로부터 완전하게 만들어진 html파일을 받아와 페이지 전체를 렌더링 하는 방식
  - Pre-rendering : 비디오를 출력 또는 재생하는 하드웨어에 의해 비디오 영상이 실시간으로 렌더링되지 않는 프로세스
- SEO나 FCP, TTI 향상을 위해서 다양한 렌더 방법이 고려 될 수 있는데 내가 선택한 라이브러리가 이를 지원 하지 않는다면 애초에 성능 개선을 위한 렌더 방법 선택을 못할 수도 있음

---

## GraphQL 도입

- 한번의 호출로 원하는 데이터를 쏙쏙 빼올 수 있는 GraphQL도 매력적인 선택
- GraphQL은 최소한의 요청으로 최적의 최소 데이터를 가져오기 때문에 성능 개선을 위한 강력한 무기가 될 수 있음

---

## JS

### 로드시 블로킹 방지

- script 로드를 위한 script 태그는 DOM 생성 블로킹을 일으킬 수 있기 때문에 HTML 최하단에 배치
- 비동기적인 로드를 위해서 async defer 속성 사용도 고려

### 로드 사이즈 줄이기

### 번들러

- Bundling 대부분 Webpack, Parcel 같은 번들러가 제공하는 기능을 이용해서 파일 사이즈를 줄일수 있음
- 번들러를 이용해서 하나의 번들로 만들면 되면 한번의 호출로 여러 자바스크립트 파일을 사용 가능
- minify 기능을 이용하면 자바스크립트를 공백을 최소한 해서 코드 라인수를 줄이게 되서 파일 크기가 줄어 들게 됨
- 트리 쉐이킹 기능을 이용하면 쓰지 않는 코드는 번들에 추가하지 않음

#### Import On Interaction

- Import On Interaction 패턴 초기 로드하는 JS 파일 크기 를 줄이기 위해서 Import On Interaction 패턴을 사용 가능
- 사용자가 특정 동작을 했을 시에 해당 쪼개진 필요한 JS 파일을 LazyLoad 하고 실행
- 특정 동작 에는 스크롤 이벤트, 라우팅, 클릭 등 다양한 상황이 해당
- ES6에서 제공하는 모듈 기능을 이용해서 Code Splitting 방법 사용
- SPA 라이브러리 내부에서 기능적으로 제공하는 경우도 많음

---

## CSS

### 로드시 블로킹 대응

- 기본적으로 CSS는 렌더링 차단 리소스
- DOM은 CSSOM이 있어야 렌더 트리가 구상되기 때문에 CSS는 항상 html 최상단 head 태그에 배치하도록 함
- 특정 조건에서만 필요한 CSS가 있을 때 미디어 쿼리를 사용하면 불필요한 블로킹을 방지 가능
- 외부 스타일시트를 가져올 때 사용하는 @import 사용은 피함

### 로드 사이즈 줄이기

- 번들러 사용으로 상당 부분 크기 줄이기 가능함

---

## 이미지

### WebP 사용

- JPEG 대신 WebP 사용하면 평균 20 30 프로 정도 크기 감소 가능
- WebP 를 지원 안하는 구버전 브라우저도 있기 때문에 점진적으로 대응

### 이미지 스프라이트

- 이미지 스프라이트는 여러 개 이미지를 하나로 만들고, CSS의 background-position 속성을 사용해 부분 이미지를 사용하는 방법

### Base64 대체

- 웹 페이지에서 사용하는 아이콘 이미지 개수가 적은 경우, 다운로드한 이미지를 사용하는 대신 이미지를 Base64로 변환해서 HTML, CSS에 포함해 사용
- 브라우저 캐싱이 안되므로 주의

### 레이지 로드 이용

- Html의 loading 옵션을 이용하거나 Intersection Observer를 활용해서 적시에 이미지를 로드 하도록 해서 초기 데이터 비용을 아낄 수 있음
- img 지연로딩
  - loading 속성을 사용해서 이미지를 브라우저 화면에 지연/병렬 로딩
  ```
     <img src="item.jpg" loading="lazy" alt>
  ```
  - auto: 디폴트 값. loading 속성을 쓰지 않은 것과 같음
  - lazy: 화상에 보이는 부분만 먼저 출력하고 화면 바깥쪽 이미지들은 로딩하지 않음, 사용자가 화면을 위로 올리면 아래쪽에 있던 이미지가 올라오면서 로딩
  - eager: 화면 위치에 상관없이 페이지가 로딩되자마자 이미지를 로드

---

### 출처

- https://www.stevy.dev/frontend-web-performance-guide-1/
