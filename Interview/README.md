# Prepare Interview

### 1. 상태관리를 왜 할까요? 그리고 평소 state 관리는 어떻게 하시나요?

- 상태관리란? (사용자와의 인터랙션을 통해) 변화하는 데이터를 관리하는 것.
- 상태의 종류? 전역상태, 컨포넌트 간 상태, 지역상태
- 상태관리 왜 필요할까? 서로 다른 두 컴포넌트에 같은 데이터가 필요하다고 할 때, 각 컴포넌트가 부모자식 관계로 되어있지 않은 이상, 각 컴포넌트 간의 직접적인 데이터 전달은 어렵기 때문
- 나의 State 관리? Redux-toolkit, React-query
  - 1. Redux-toolkit
  - 미들웨어 추가와 immer가 내장되어 있어 편리
  - redux보다 action type이나 action creator를 따로 생성하지 않아서 보일러플레이트 코드 줄어듦
  - 2. React-query
  - 데이터를 캐싱한다는 점으로 API를 줄여줄 수 있음
  - 바로바로 데이터 업데이트 가능
  - 편리한 사용법

### 2. Redux가 무엇인가요, 왜 Redux를 사용하시나요?

- 전역 상태관리를 하기 위한 상태관리 라이브러리
- 리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 코드를 다른 파일로 분리시켜서 효율적으로 관리 가능

### 3. Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요

- Recoil
  - React의 useState 훅과 비슷하게 동작하는, 직관적이면서 간단한 구조 (코드의 양은 매우 줄어듦)
  - Redux처럼 따로 안정적인 Devtool이 아직 없음. snapshot이라는 개념이 존재하지만, 직관적으로 볼 수 있는 것은 아니고 콘솔을 이용하는 형태로 볼 수 있음

### 4. 버츄얼 돔과 리얼 돔의 차이를 설명해주세요

- 돔 : 웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있게끔 브라우저가 트리구조로 만든 객체 모델을 의미
- 가상 DOM은 DOM의 상태를 메모리 위에 계속 올려두고,
  DOM에 변경이 있을 경우 해당 변경을 반영

### 5. useRef에 대해 설명해보세요

- 리렌더링을 하지 않음, 컴포넌트의 속성만 조회&수정함
- 사용하는 경우
  - 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때.
  - 애니메이션을 직접적으로 실행시킬 때.
  - 서드 파티 DOM 라이브러리를 React와 같이 사용할 때.

### 6. useEffect의 실행 순서에 대해 설명해주세요

- bottom - top 방식으로 작동
- 컴포넌트가 렌더링이 된 후에 실행(return 문이 useEffect 보다 먼저 읽힘)

### 7. var, let, const의 차이에 대해 알려주세요.

- var : 중복 선언 가능, 함수레벨 스코프
- let : 중복 선언 불가능, 재할당 가능(immutable true), 블록레벨 스코프
- const : 중복 선언 불가능, 재할당 불가능(immutable false), 블록레벨 스코프

### 8. Async/Await와 Promise의 차이

- 에러 핸들링
  - Promise 를 활용할 시에는 .catch() 문을 통해 에러 핸들링이 가능하지만, async/await 은 에러 핸들링 할 수 있는 기능이 없어 try-catch() 문을 활용
- 코드 가독성
  - Promise의 .then() 지옥의 가능성
  - 코드가 길어지면 길어질수록, async/await 를 활용한 코드가 가독성이 좋음
  - async/await 은 비동기 코드가 동기 코드처럼 읽히게 해줌. 코드 흐름을 이해 하기 쉬움

### 9. 데이터 10,000개를 가지고 무한 스크롤 구현시에 가장 중요하게 고려해야 할점은?

- 현재 위치가 명확하지 않음
- 로드할 데이터가 없음을 명시
- 성능이 저하
- _실제 사용시에는 로딩중일 때 요청을 보내지 않도록 추가 조치가 필요_
  - 무한 스크롤은 스크롤을 내릴 때 요청을 보내기 때문에 무한으로 요청을 보내게 될 수 있기에 요청을 이미 보내는 중이면 이후에 스크롤을 내려도 요청을 보내지 않도록 조치

### 10. CloudFront를 사용해본적이 있나요? 사용해봤다면, CloudFront로 배포하는 이유를 설명해주세요.

- S3 버킷만으로 정적 웹 호스팅으로 서비스 하기에는 문제가 있음

  - http 통신
  - 버킷이 퍼블릭 공개
  - S3 엔드 포인트 주소를 그대로 사용해야한다는 점

- 이런 문제들을 해결하기 위해 S3 버킷에 연결할 AWS Cloudfront 서비스가 필요

### 11. useEffect와 useLayoutEffect 차이에 대해 설명해주세요.

- useEffect(비동기적)는 랜더링된 이후에 동작하는 hook이고, useLayoutEffect(동기적)는 랜더링 되기 이전에 동작하는 hook
- DOM에서 동기적으로 리랜더링이 일어나면 앞선 작업이 끝나기 전까지 유저는 DOM를 제대로 보지 못함. 그래서 비동기적으로 동작하는 useEffect를 먼저 사용하라고 권하는 것
- 동기적인 랜더링, 깜빡임 등에 useLayoutEffect를 제한적으로 고려

### 12. Closure란? (공부해야함!!!!!)

- 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수

### 13. Javascript 호이스팅에 대해 설명해주세요.

- 함수가 실행되기 전에 JS 엔진이 안에 있는 변수를 범위의 최상단으로 끌어 올리는 것
- 변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임 runtime이 아니라 그 이전 단계에서 먼저 실행됨
- **변수 호이스팅 Variable Hoisting** : 변수 선언문이 코드의 섣두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

### 14. 프로세스 생성 과정에 대해 설명해보세요.

- 프로세스란 실행중에 있는 프로그램
- 실행파일 클릭 -> 실행을 위한 메모리 할당 -> 메모리 공간으로 바이너리 코드 올라감 -> 그 순간부터 프로그램은 프로세스라고 불림
- 프로세스 생성과정
  - PCB가 생성되며 OS가 실행한 프로그램의 코드를 읽어들여 프로세스에 할당된 메모리의 Text segment에 저장
  - 초기화된 전역 변수 및 static 변수를 data segment에 할당
  - HEAP과 Stack은 초기 메모리 주소만 초기화됨
  - PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기까지 대기

### 15. HTTPS란?

- HTTPS (HTTP Secure) 는 HTTP protocol의 암호화된 버전
- 클라이언트와 서버 간의 모든 커뮤니케이션을 암호화 하기 위하여 SSL 이나 TLS을 사용
- 이 커넥션은 클라이언트가 민감한 정보를 서버와 안전하게 주고받도록 해줌

### 16. TCP란 무엇인가?

- 인터넷 상에서 데이터를 메시지 형태로 보내기 위해 IP와 함께 사용하는 프로토콜(Transmission Control Protocol)
- TCP (전송 제어 프로토콜)은 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜
- TCP의 역할은 에러가 없이 패킷이 신뢰할 수 있게 전달 되었는지 보증해 주는 것
- TCP는 동시제어가 가능 -> 이는 초기 요청이 작게 시작해도 컴퓨터들과 서버들의 대역폭의 깊이가 증가해도 네트워크가 지원할 수 있다는 것을 뜻함
  - 패킷 : 인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송을 하는데 이때, 이 조각을 패킷

### 17. TCP와 UDP의 차이점은?

- UDP(User Datagram Protocol) : 데이터를 데이터그램(독립적인 관계를 지니는 패킷) 단위로 처리하는 프로토콜

<img src="https://images.velog.io/images/daon9apples/post/f4f756e7-c6f5-41bd-8467-e381517be404/image.png" width="600">

### 18. 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가?

- 브라우저 주소창에 maps.google.com을 입력한다.
- 브라우저가 maps.google.com의 IP 주소를 찾기 위해 캐시에서 DNS 기록을 확인한다.
- 만약 요청한 URL(maps.google.com)이 캐시에 없다면, ISP의 DNS 서버가 DNS 쿼리로 maps.google.com을 호스팅하는 서버의 IP 주소를 - 찾는다.
- 브라우저가 해당 서버와 TCP 연결을 시작한다.
- 브라우저가 웹서버에 HTTP 요청을 보낸다.
- 서버가 요청을 처리하고 응답을 보낸다.
- 서버가 HTTP 응답을 보낸다.
- 브라우저가 HTML 컨텐츠를 보여준다.

### 19. JavaScript Event Loop

<img src="https://github.com/YooJinRa/til/blob/main/Javascript/ExecutionContextMySelf.jpeg" width="800">

### 20. RESTFul API란?

- RESTful은 REST의 설계 규칙을 잘 지켜서 설계된 API를 RESTful한 API
  - REST API : REST의 특징을 기반으로 서비스 API를 구현한 것
  - 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능한 것
  - URI는 정보의 자원을 표현 / 자원에 대한 행위는 HTTP Method(GET, POST, PUT, PATCH, DELETE)로 표현 / 행위(Method)는 URI에 포함하지 않음

### 21. GET, POST 방식의 차이점

- GET, POST 방식 모두 브라우저가 서버에 요청하는 것
- GET, POST 방식 차이점
  - GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트 할 때 사용
  - GET 은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없으나, POST 는 body 에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재
  - GET 요청은 멱등이며, POST는 멱등이 아님
    - _멱등성 : 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질_

### 22. Webpack 써보신 적 있나요

- SPA(single page app)는 하나의 html에 수십, 수백 개의 자바스크립트 파일을 포함하기 때문에
- 자바스크립트는 태생이 브라우저에 종속적이었기 때문에 자체적인 모듈 시스템이 없었음
- 자바스크립트를 브라우저 밖에서 사용할 수 있게 하려는 노력 -> 대표적 CommonJS, AMD -> 자바스크립트를 범용적으로 사용하기 위해서 하는 대부분의 일은 모듈 시스템을 정의하는 일 -> nodejs 같은 프레임워크가 등장
- webpack은 CommonJS와 AMD 스펙 모두를 지원
- webpack을 사용하면 여러 개의 자바스크립트 파일을 하나의 파일(원한다면 여러 개)로 컴파일할 수 가능해짐
- 필요한 라이브러리를 npm으로 설치 후 필요한 부분에 import만 하면 바로 사용 가능

### 23. TCP와 UDP의 차이점

### 24. 동기와 비동기의 차이

- 동기 방식은 서버에서 요청을 보냈을 때 응답이 돌아와야 다음 동작을 수행 가능
- 비동기 방식은 반대로 요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행 할 수 있음

### 25. Array vs LinkedList

- Array 의 element 들은, 인접한 memory 위치에 저장 / Memory 는 Array 가 선언되자 마자 Compile time 에 할당
- LinkedList 의 element 들은, memory 어딘가에 저장 / Memory 는 새로운 node 가 추가될 때 runtime 에 할당

- 데이터 접근이 주 업무일 경우 → Array / 데이터 수정이 주 업무일 경우 → Linked List

### 26. 서버 사이드 렌더링이란?

- 서버에서 페이지를 그려 클라이언트(브라우저)로 보낸 후 화면에 표시하는 기법

### 27. MVC 패턴이란 무엇인가?

- MVC 는 Model, View, Controller의 약자
- 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴

### 28. 아토믹 디자인 패턴에 대해 아는가?

- 가장 작은 컨포넌트 단위를 원자로 설정하고 이를 바탕으로 상위 컴포넌트를 만들어 코드 재사용을 최대화하는 방법론
- 원자 -> 분자 -> 유기체 -> 템플릿 -> 페이지

### 29. 웹 스토리지의 차이점

- 웹 스토리지

  - 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 추가된 저장소
  - 간단한 Key-Value 스토리지 형태
  - 쿠키와 달리 자동 전송의 위험성이 없음
  - 오리진(Origin)(도메인,프로토콜,포트) 단위로 접근이 제한되는 특성 덕분에 CSRF로 부터 안전
  - 쿠키보다 큰 저쟝 용량 지원(모바일 2.5MB, 데스크탑 5~10MB)
  - 서버가 HTTP 헤더를 통해 스토리지 객체를 조작할 수 없음(웹 스토리지 객체 조작은 JavaScript 내에서만 수행)
  - 오직 문자형(string) 데이터 타입만 지원
  - 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage)가 있으며, 같은 Storage 객체를 상속하기 때문에 메서드가 동일

- 로컬 스토리지(localStorage)

  - 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 종료해도 계속 브라우저에 남아있음 (영구성) / 단, 동일한 브라우저를 사용할 때만 해당
  - 지속적으로 필요한 데이터 저장(자동 로그인 등)

- 세션 스토리지(sessionStorage)
  - 데이터가 오리진 뿐만 아니라 브라우저 탭에도 종속되기 때문에, 윈도우나 브라우저 탭을 닫을 경우 제거
  - 일시적으로 필요한 데이터 저장(일회성 로그인 정보, 입력폼 저장 등)

### 30. http vs https 차이점에 대해 설명해주세요

- SSL 인증서
  - SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화
- TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지함
  - TSL은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공

### 31. 웹 프로토콜이란?

- 웹에서 쓰이는 통신규약
  - protocol : 문서에 접근하기 위해 사용하는 프로토콜 이름
  - computer_name : 문서가 있는 컴퓨터(서버)의 도메인 이름
  - port : 서버가 어떤 포트 숫자를 바라보고 있는지 (선택)
  - document_name : 서버 컴퓨터에 있는 특정 문서의 이름
  - parameters: 페이지에 넘기는 변수 (선택)

### 32. AJAX란 무엇인가

- Asynchronous JavaScript and XML의 약자
- 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법의 하나
- Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있음. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시 가능

### 33. Promise와 Callback의 차이점은

- callback을 사용하면 비동기 로직의 결과값을 처리하기 위해서는 callback안에서만 처리를 해야하고, 콜백 밖에서는 비동기에서 온 값을 알 수가 없음
- 하지만 promise를 사용하면 비동기에에서 온 값이 promise 객체에 저장되기 때문에 코드 작성이 용이

### 34. 자바스크립트와 타언어의 차이점

- 자바스크립트는 동적 프로토 타입 기반 객체 지향언어(java와 다르게 클래스 개념이 없음)
- 자바스크립트는 싱글스레드기반 비동기처리

### 35. ES6의 호환성 해결방법은?

- 브라우저 별로 구동원리 또는 JS엔진 등의 차이가 있기 때문에 브라우저 호환성 이슈가 발생하는데,
- 이러한 차이를 최소화해 런타임 환경에 맞게 최적화 하는 작업을 크로스 브라우징이라고 하는데,
- Javascript의 호환성에 따른 충돌이나 부작용을 줄이기 위한 방법으로는 Babel이라는 도구를 사용하면 됨
- 바벨은 주로 ES5 이상 버전의 코드를 현재 및 과거의 브라우저와 같은 환경에서 호환되는 버전으로 변환하는데 사용되는 도구로, IE나 다른 브라우저에서 동일한 기능을 제공하고 side-effect를 최소한으로 줄일수 있음

### 36. babel은 컴파일러 인가 ? 트랜스파일러인가?

- JavaScript 트랜스컴파일러
- 트랜스파일러란 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른언어로 변환하는 것을 의미
- 컴파일은 한 언어로 작성된 코드를 다른 언어로 변환하는 것
- React는 일반적으로 JSX라는 특수한 문법을 사용하여 코딩을 하기 때문에 개발자가 작성한 원본 코드는 브라우저에서 제대로 실행이 되지 않음 -> 따라서 보통 Webpack 번들러와 Babel 로더를 이용하여 React 프로젝트를 빌드

### 37. ES6에 추가된 것은 무엇인가?

- String Literal, 객체 비구조화 ( Object Destructuring ), 객체 리터럴 ( Object Literal ), for .. of, Spread Operator, Rest Parameter, Arrow Function, Default Params, includes, Trailing Commas, Map & Set

### 38. Context API란?

- 컴포넌트를 건너띄고 다른 컴포넌트에서 state, function을 사용할 수 있음
- redux의 많은 어려운 개념보다 context api는 Provider, Consumer, createContext 개념만 알면 적용가능
- context는 컴포넌트안에서 전역적으로 데이터를 공유하도록 나온 개념
  - 로그인 데이터, 웹 내 사용자가 쓰는 설정파일, 테마, 언어 등 다양하게 컴포넌트간 공유되어야할 데이터로 사용

### 39. 라이프사이클 메소드에 대해 설명

- render() : 컨포넌트 모양새 정의 / 라이프사이클 메서드 중 유일 필수 메소드 / this.props와 this.state에 접근하며, 리액트 요소(태그 또는 컴포넌트)를 반환
- constructor(props){...} : 컨포넌트 생성자 메소드, 컨포넌트를 만들때 처음으로 실행 / 초기 state 정의 가능
- getDerivedStateFromProps 메소드 : props로 받아 온 값을 state에 동기화시키는 용도 / 컴포넌트가 마운트/업데이트 될 때 사용
- componentDidMount() {...} : 컴포넌트를 만들고 첫 렌더링을 마친 후 실행 / 비동기 작업을 처리
- shouldComponentUpdate(nextProps, nextState) {...} : props나 state를 변경했을 때, 리렌더링을 시작할지 여부를 지정하는 메서드 / 반드시 true/false 값을 반환 / 현재 props/state는 this.props와 this.state로 접근, 새로 설정될 props/state는 nextProps와 nextState로 접근
- getSnapshotBeforeUpdate : render에서 만들어진 결과물이 브라우저에 실제로 반영되기 직전에 호출 / 업데이트하기 직전 값을 참고할 때 사용(eg. 스크롤바 위치 유지)
- componentDidUpdate(prevProps, prevState, snapshot) {...} : 리렌더링 완료 후 실행 / DOM 관련 처리를 해도 괜찮음(업데이트가 끝난 직후이기 때문) / prevProps/prevState를 사용해 컴포넌트가 이전에 가졌던 데이터에 접근 가능 / getSnapshotBeforeUpdate의 반환값을 snapshot 파라미터로 사용 가능
- componentWillUnmout(){...} : 컴포넌트를 DOM에서 제거할 때 실행 / componentDidMount에서 등록한 이벤트, 타이머, 직접 생성한 DOM은 여기서 제거작업을 해야 함
- componentDidCatch : 컴포넌트 렌더링 도중 에러가 발생했을 때 애플리케이션이 먹통이 되지 않고 오류 UI를 보여주게 해줌

### 40. react 클래스형과 함수형의 차이

- 클래스형
  - state, LifeCycle Api 사용 가능
  - 임의의 메서드 정의 가능
- 함수형
  - state, LifeCycle Api 사용 가능(16.8 이후 제공되는 hook으로 해결가능)
  - 선언하기 클래스형 보다 편리
  - 메모리 자원을 클래스형보다 덜 사용
  - 빌드한 결과물의 크기가 클래스형보다 작음

### 41. 타입스크립트란?

- 자바스크립트의 경우는 동적 타입 언어(dynamic type language)이기 때문에 런타임 속도는 빠르지만 타입 안정성이 보장되지 않음
- 타입스크립트는 자바스크립트의 이러한 단점을 보완하기 위해서 만들어 짐 -> 이러한 이유로 MS에서는 타입스크립트에 “JavaScript that scales(확장된 자바스크립트)”라는 슬로건을 만듬
- 타입스크립트는 정적 타입 언어(static type language)이기 때문에 컴파일 시 시간이 조금 걸리더라도 안정성을 보장한다는 점이 장점

### 42. Angular와 React의 차이점

- 앵귤러 : 타입스크립트 기반 프레임워크 / 양방향 바인딩 지원 / Incremental DOM / Component 와 Service 단의 분리
- 리액트 : 자바스크립트 라이브러리 / Virtual DOM

### 43. SEO란?

- SEO(검색 엔진 최적화)는 웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정
  - 검색 엔진은 웹을 크롤링 (en-US)하면서 페이지에서 페이지로 링크를 따라가고, 찾은 콘텐츠의 색인(검색 결과에 보이는 것)을 생성
  - 크롤러는 일정 규칙을 따르므로, SEO를 진행하며 해당 규칙을 밀접하게 따라가면 웹사이트가 검색 결과의 보다 높은 곳에 노출돼 (전자상거래와 광고라면) 수익으로 연결될 수도 있음

### 44. 이벤트 위임이란?

- 이벤트 위임은 캡쳐링과 버블링을 이용한 것으로, 여러 엘리먼트마다 각각 이벤트 핸들러를 할당하지 않고, 공통되는 부모에 이벤트 핸들러를 할당하여 이벤트를 관리하는 방식

### 45. 메모이제이션이란?

- 메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술
- 리액트 메모이제이션 하는 이유
  - 비싼 연산을 반복하는 것을 피하여 성능을 향상
  - 안정된 값 제공

### 46. 이벤트 버블링이란

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작

### 47. 부모에서 자식으로 이벤트상속방법

- 이벤트 캡처링으로 부모에서 자식으로 이벤트를 상속 가능
- 이벤트 캡처링은 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하며 이벤트를 전파하는 방식 (부모 -> 자식)

### 48. 이벤트버블링을 막는 방법

- 이벤트 객체의 메서드인 event.stopPropagation()를 사용
- 버블링을 멈추고, 요소에 할당된 다른 핸들러의 동작도 막으려면 event.stopImmediatePropagation()을 사용 -> 이 메서드를 사용하면 요소에 할당된 특정 이벤트를 처리하는 핸들러 모두가 동작하지 않음
- 핸들러의 event 객체에 데이터를 저장해 다른 핸들러에서 읽을 수 있게 하면, 아래쪽에서 무슨 일이 일어나는지를 부모 요소의 핸들러에게 전달할 수 있으므로, 이 방법으로도 이벤트 버블링을 통제 가능

### 49. 이벤트버블링 활용 방법

- 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식으로 이벤트 버블링을 활용(이벤트 위임)
- 이벤트 버블링을 응용하여 부모 엘리먼트에 리스너를 위임하여 부착하면, 리스너의 개수를 1개로 줄여 최적화 가능

### 50. React, 왜 사용하시나요?

- SPA
- React Native 앱 개발 가능
- 수 많은 커뮤니티
- 컨포넌트 재사용 가능(유지보수 용이)
