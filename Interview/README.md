# Prepare Interview

### 1. 🌱상태관리를 왜 할까요? 그리고 평소 state 관리는 어떻게 하시나요?

> 상태관리란 사용자와의 인터렉션(서로 영향을 주고 받는 일종의 행동)을 통해 변화하는 데이터를 관리하는 것을 말합니다. <br>
> 리액트의 특징 중 하나가 단방향 통신을 하기에 서로 다른 두 컴포넌트에 같은 데이터가 필요하다고 할 때, 각 컨포넌트가 부모자식 관계로 되어 있지 않는 이상 각 컴포넌트간의 직접적인 데이터 전달이 어렵기 때문에 상태관리가 필요합니다.<br>
>
> 평소 state관리를 Redux-toolkit(RTK)과 React-query로 합니다.<br>
> RTK 사용하는 이유는 상태관리를 전역에서 진행시킬 수 있고, redux보다 action type이나 action creator를 따로 생성하지 않아서 보일러플레이트 코드가 줄어들기 때문입니다.<br>
> 또한 thunk가 내장되어 있어 미들웨어 추가가 편리하고, immer가 내장되어 있어 불변성 관리가 수월하기 때문에 사용합니다.<br>
>
> React-query를 사용하는 이유는 컨포넌트 내에서 사용할 수 있고, 데이터를 캐싱하기 때문에 API 호출을 줄여줄 수 있습니다. 또한 바로바로 데이터가 업데이트가 가능하고 편리한 사용법 때문에 사용합니다.<br>

- 상태관리란? (사용자와의 인터랙션을 통해) 변화하는 데이터를 관리하는 것.
- 상태의 종류? 전역상태, 컨포넌트 간 상태, 지역상태
- 상태관리 왜 필요할까? 서로 다른 두 컴포넌트에 같은 데이터가 필요하다고 할 때, 각 컴포넌트가 부모자식 관계로 되어있지 않은 이상, 각 컴포넌트 간의 직접적인 데이터 전달은 어렵기 때문
- 나의 State 관리? Redux-toolkit, React-query
  - 1. Redux-toolkit
  - 미들웨어 추가와 immer가 내장되어 있어 편리
  - redux보다 action type이나 action creator를 따로 생성하지 않아서 보일러플레이트 코드 줄어듦
  - 2. React-query
  - 데이터를 캐싱한다는 점으로 API를 줄여줄 수 있음
  - 바로바로 데이터 업데이트 가능
  - 편리한 사용법

### 2. 🌱Redux가 무엇인가요, 왜 Redux를 사용하시나요?

> 리덕스는 전역 상태관리를 하기 위한 상태관리 라이브러리 입니다. <br>
> 리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 코드를 다른 파일로 분리시켜서 효율적으로 관리 가능하기 때문입니다.<br>

- 전역 상태관리를 하기 위한 상태관리 라이브러리
- 리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 코드를 다른 파일로 분리시켜서 효율적으로 관리 가능

### 3. 🌱Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요

> 리코일은 React의 useState 훅과 비슷하게 동작하고, 직관적이면서 간단한 구조를 가지고 있습니다. (코드의 양은 매우 줄어듦) 하지만, Redux처럼 따로 안정적인 Devtool이 아직 없습니다. snapshot이라는 개념이 존재하지만, 직관적으로 볼 수 있는 것은 아니고 콘솔을 이용하는 형태로 볼 수 있습니다. <br>

- Recoil
  - React의 useState 훅과 비슷하게 동작하는, 직관적이면서 간단한 구조 (코드의 양은 매우 줄어듦)
  - Redux처럼 따로 안정적인 Devtool이 아직 없음. snapshot이라는 개념이 존재하지만, 직관적으로 볼 수 있는 것은 아니고 콘솔을 이용하는 형태로 볼 수 있음

### 4. 🌱버츄얼 돔과 리얼 돔의 차이를 설명해주세요

> 돔이란 Document object Model 문서객체모델의 약자입니다.<br>
> 문서객체란 Web browser안에서 HTML 문서에 Javascript가 접근할 수 있도록 html 태그를 객체로 만든 것입니다.<br>
>
> 기존의 렌더링 방식을 보면,<br>
> 브라우저는 서버가 보내준 html 파일을 해석하여 dom트리를 만들고,<br>
> 브라우저는 서버가 보내준 css 파일을 해석해서 cssom트리도 만들고,<br>
> dom트리와 css트리를 합쳐서 렌더트리를 만듭니다.<br>
> 렌더트리로 각 노드의 위치와 크기를 계산해 레이아웃을 만들고,<br>
> 뷰포트 내에서 각 노드들의 위치와 크기도 계산합니다.<br>
> 레이아웃 계산이 완료되면 실제 화면을 그리는 페인트를 합니다.<br>
>
> 여기서 문제점은 돔은 새로운 요청이나 변경사항이 있을 때마다 매번 리렌더링을 합니다. 매번 새롭게 구성하기 때문에 렌더할 양이 많아지면 속도가 느려지게 됩니다.<br>
>
> 때문에 가상돔이 나왔습니다.<br>
> 가상돔은 돔의 구조를 흉내낸 Javascript 객체(트리구조)입니다.<br>
> In-memory에 존재하기 때문에 실제로 렌더 되지 않습니다.<br>
>
> 리액트가 가상돔을 반영하는 절차를 보면,<br>
> 변경사항이 있으면 UI를 가상돔에 리렌더링 합니다.<br>
> 가상돔끼리 비료하고, 변경된 부분만 실제 돔에 적용시킵니다.<br>

- 돔 : 웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있게끔 브라우저가 트리구조로 만든 객체 모델을 의미
- 가상 DOM은 DOM의 상태를 메모리 위에 계속 올려두고,
  DOM에 변경이 있을 경우 해당 변경을 반영

### 5. 🌱useRef에 대해 설명해보세요

> useRef는 저장공간(변수관리)이나 Dom요소에 접근하기 위해 사용되는 훅입니다.<br>
>
> State 값을 바꿀때 대표적으로 사용되는 훅이 useState인데, useRef는 ref 안에 값을 아무리 변경해도 컨포넌트는 다시 렌더링이 되지 않습니다. 즉 state 대신 Ref를 사용하면 불필요한 렌더링을 막을 수 있습니다.<br>
> 또한 컨포넌트가 렌더링이 되어도 ref안에 저장되어 있는 값은 변화되지 않고 그대로 유지가 됩니다. 이에 변경시 렌더링을 발생시키지 말아야 하는 값을 다룰 때 편리합니다.<br>
>
> Dom요소에 접근에 대해서는 보통 dom에 접근해서 focus하는 곳에 많이 사용한다 합니다.<br>
> querySelector 를 사용해서도 dom요소를 접근할 수 있지만,<br>
> React에서 querySelector 를 사용하게되면, 실제 DOM의 요소를 가져오게 됩니다. <br>
> 하지만 React는 Virtual DOM을 통해 Real DOM을 그리기 때문에, React가 제어하고있는 Virtual DOM 안에 있는 요소가 더 신뢰할 것 같습니다.<br>

- 리렌더링을 하지 않음, 컴포넌트의 속성만 조회&수정함
- 사용하는 경우
  - 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때.
  - 애니메이션을 직접적으로 실행시킬 때.
  - 서드 파티 DOM 라이브러리를 React와 같이 사용할 때.

### 6. 🌱useEffect의 실행 순서에 대해 설명해주세요

> useEffect는 bottom-top 방식으로 동작합니다. <br>
> Return 문이 읽히고 useEffect함수가 읽힙니다. 즉 컴포넌트가 렌더링 된 이후에 useEffect가 실행됩니다.<br>

- bottom - top 방식으로 작동
- 컴포넌트가 렌더링이 된 후에 실행(return 문이 useEffect 보다 먼저 읽힘)

### 7. 🌱var, let, const의 차이에 대해 알려주세요.

> 변수는 하나의 값을 저장하기 위해 확보한 메모리공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름입니다. <br>
> 변수의 선언은 var const let 키워드로 할 수 있고, 선언->초기화 단계를 거쳐서 수행됩니다.<br>
>
> Var 키워드를 이용한 변수 선언은 선언단계와 초기화 단계가 동시에 진행되며 암묵적으로 undefined를 할당해 초기화 합니다.<br>
> 이는 변수 선언이 런타임에서 되는게 아니라 그 이전단계에서 먼저 실행되기 때문입니다.<br>
> 자바스크립트 엔진은 소스코드를 한줄씩 순차적으로 실행하기 앞서 선언문을 찾아내 먼저 실행시킵니다. 이것을 호이스팅이라 합니다.<br>
>
> Var 키워드의 경우 변수 중복선언이 가능하고, 예기치 못한 값을 반환시킬 수 있고, 함수레벨스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수가 됩니다. <br>
> 또한 변수 선언문 이전에 변수를 참조하면 언제는 undefined를 반환하는 문제가 있습니다.<br>
>
> 이에 es6에서 let과 const 키워드가 이 문제점을 해결했습니다.<br>
>
> Let은 변수 중복선언 불가하지만 재할당 가능합니다.<br>
> const는 반드시 선언과 초기화를 동시에 진행해야 합니다. 또한 중복선언 불가하고, 재할당도 불가합니다.<br>
>
> Let 변수는 선언단계와 초기화 단계가 분리되어 진행됩니다. 런타임 이전에 자바스크립트 엔진에 의해 선언 단계가 먼저 실행되지만, 초기화 단계가 실행되지 않을 때 해당 변수에 접근하려고 하면 참조에러가 발생합니다. 일시적사각지대 TDZ 구간에 존재하기 때문입니다.<br>

- var : 중복 선언 가능, 함수레벨 스코프
- let : 중복 선언 불가능, 재할당 가능(immutable true), 블록레벨 스코프
- const : 중복 선언 불가능, 재할당 불가능(immutable false), 블록레벨 스코프

### 8. 🌱Async/Await와 Promise의 차이

> Promise 를 활용할 시에는 .catch() 문을 통해 에러 핸들링이 가능하지만, async/await 은 에러 핸들링 할 수 있는 기능이 없어 try-catch() 문을 활용해야합니다. <br>
> 그리고 Promise는 .then() 지옥의 가능성이 있으며 반면에 async/await를 활용한 코드는 가독성이 좋습니다.<br>
> async/await 은 비동기 코드가 동기 코드처럼 읽히게 해주며 코드 흐름을 이해 하기 쉽게 해줍니다.<br>

- 에러 핸들링
  - Promise 를 활용할 시에는 .catch() 문을 통해 에러 핸들링이 가능하지만, async/await 은 에러 핸들링 할 수 있는 기능이 없어 try-catch() 문을 활용
- 코드 가독성
  - Promise의 .then() 지옥의 가능성
  - 코드가 길어지면 길어질수록, async/await 를 활용한 코드가 가독성이 좋음
  - async/await 은 비동기 코드가 동기 코드처럼 읽히게 해줌. 코드 흐름을 이해 하기 쉬움

### 9. 🌱데이터 10,000개를 가지고 무한 스크롤 구현시에 가장 중요하게 고려해야 할점은?

> 실제 사용시 로딩중인 경우에는 요청을 보내지 않도록 추가 조치가 필요합니다.<br>
> 무한 스크롤은 스크롤을 내리때 요청을 보내기 때문에 무한으로 요청이 보내게 될 수 있습니다. 따라서 요청을 보내는 중이라면 이후 스크롤을 내려도 요청을 보내지 않도록 조치하는 것이 중요할 것이라고 생각합니다.<br>

- 현재 위치가 명확하지 않음
- 로드할 데이터가 없음을 명시
- 성능이 저하
- _실제 사용시에는 로딩중일 때 요청을 보내지 않도록 추가 조치가 필요_
  - 무한 스크롤은 스크롤을 내릴 때 요청을 보내기 때문에 무한으로 요청을 보내게 될 수 있기에 요청을 이미 보내는 중이면 이후에 스크롤을 내려도 요청을 보내지 않도록 조치

### 10. 🌱CloudFront를 사용해본적이 있나요? 사용해봤다면, CloudFront로 배포하는 이유를 설명해주세요.

> S3 버킷 만으로는 정적 웹 호스팅 서비스하기에 문제가 있습니다.<br>
> 우선 http통신을 하며 버킷이 퍼블릭으로 공개가 됩니다. 마지막으로 S3 엔드포인트 주소를 그대로 사용한다는 점입니다. 이런 문제들을 해결하기 위해 S3버킷에 연결할 CloudFront서비스가 필요하다고 생각합니다.<br>

- S3 버킷만으로 정적 웹 호스팅으로 서비스 하기에는 문제가 있음

  - http 통신
  - 버킷이 퍼블릭 공개
  - S3 엔드 포인트 주소를 그대로 사용해야한다는 점

- 이런 문제들을 해결하기 위해 S3 버킷에 연결할 AWS Cloudfront 서비스가 필요

### 11. 🌱useEffect와 useLayoutEffect 차이에 대해 설명해주세요.

> useEffect는 비동기로 함수가 실행되며, 렌더링이 된 이후에 동작하는 hook입니다.<br>
> 반면, useLayputEffect는 동기로 함수가 실행되며, 랜더링 되기 이전에 동작하는 hook입니다.<br>
> dom에서 동기적으로 리랜더링이 일어나면 앞선 작업이 끝나가 전까지 유저는 DOM에서 제대로 보지 못하게 됩니다. 이 때문에 비동기적으로 동작하는 useEffect를 먼저 사용해보는 것을 고려하는게 좋습니다.<br>
> 단 동기적인 랜더링이 필요하거나 깜박임 등이 일어나면 useLayoutEffect를 제한적으로 고려해보는 게 좋습니다.<br>

- useEffect(비동기적)는 랜더링된 이후에 동작하는 hook이고, useLayoutEffect(동기적)는 랜더링 되기 이전에 동작하는 hook
- DOM에서 동기적으로 리랜더링이 일어나면 앞선 작업이 끝나기 전까지 유저는 DOM를 제대로 보지 못함. 그래서 비동기적으로 동작하는 useEffect를 먼저 사용하라고 권하는 것
- 동기적인 랜더링, 깜빡임 등에 useLayoutEffect를 제한적으로 고려

### 12. 🌱Closure란?

> 클로저는 함수와 렉시컬환경(정적스코프)의 조합입니다.<br>
> 여기서 렉시컬 스코프란 함수가 만들어진 위치에 따라 스코프를 결정하는 것을 말합니다.<br>
> 클로저는 자기 스코프에 없는 변수를 상위 스코프에 가서 그 변수에 접근하는 함수를 말합니다. 즉 클로저는 상위 스코프의 변수를 가리키는 함수이고 클로저가 만들어진 환경을 기억하고 있습니다. 그리고 클로저는 함수 생성시점에 언제나 생긴다고 합니다. 그 말은 즉슨 모든 함수는 클로저입니다. 호출한 렉시컬 환경을 기억하는 함수이기 때문입니다.<br>
>
> 반복문과 비동기 함수가 만날때 문제가 자주 발생하는데, 클로저의 특성을 사용해서 해결할 수 있습니다.<br>
> (비동기에서 함수 안의 변수는 실행될 때 값이 결정되기 때문)<br>

- 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수

### 13. 🌱Javascript 호이스팅에 대해 설명해주세요.

> 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 앞서 선언문을 찾아내 메모리공간을 선언전에 미리 할당시킵니다. 이것을 호이스팅이라 합니다.<br>
> 호이스팅에는 변수 호이스팅과 함수 호이스팅이 있습니다. 변수 호이스팅과 함수호이스팅의 차이는 변수는 undefined로 초기화 되며, 함수 호이스팅은 함수 객체로 초기화 됩니다.<br>
> 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이기 때문에 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약표현과 동일하게 동작합니다.<br>
>
> 함수 표현식 이전에 함수를 참조하면 undefined로 평가되어 타입에러가 발생하기에 함수 표현식 이후에 참조 또는 호출해야 합니다.<br>
> 반면 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야한다는 규칙을 무시합니다. 이 때문에 함수선언문 대신 함수 표현식을 사용할 것을 권장한다 합니다.<br>

- 함수가 실행되기 전에 JS 엔진이 안에 있는 변수를 범위의 최상단으로 끌어 올리는 것
- 변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임 runtime이 아니라 그 이전 단계에서 먼저 실행됨
- **변수 호이스팅 Variable Hoisting** : 변수 선언문이 코드의 섣두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

### 14. 프로세스 생성 과정에 대해 설명해보세요.

- 프로세스란 실행중에 있는 프로그램
- 실행파일 클릭 -> 실행을 위한 메모리 할당 -> 메모리 공간으로 바이너리 코드 올라감 -> 그 순간부터 프로그램은 프로세스라고 불림
- 프로세스 생성과정
  - PCB가 생성되며 OS가 실행한 프로그램의 코드를 읽어들여 프로세스에 할당된 메모리의 Text segment에 저장
  - 초기화된 전역 변수 및 static 변수를 data segment에 할당
  - HEAP과 Stack은 초기 메모리 주소만 초기화됨
  - PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기까지 대기

### 15. HTTPS란?

- HTTPS (HTTP Secure) 는 HTTP protocol의 암호화된 버전
- 클라이언트와 서버 간의 모든 커뮤니케이션을 암호화 하기 위하여 SSL 이나 TLS을 사용
- 이 커넥션은 클라이언트가 민감한 정보를 서버와 안전하게 주고받도록 해줌

### 16. TCP란 무엇인가?

- 인터넷 상에서 데이터를 메시지 형태로 보내기 위해 IP와 함께 사용하는 프로토콜(Transmission Control Protocol)
- TCP (전송 제어 프로토콜)은 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜
- TCP의 역할은 에러가 없이 패킷이 신뢰할 수 있게 전달 되었는지 보증해 주는 것
- TCP는 동시제어가 가능 -> 이는 초기 요청이 작게 시작해도 컴퓨터들과 서버들의 대역폭의 깊이가 증가해도 네트워크가 지원할 수 있다는 것을 뜻함
  - 패킷 : 인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송을 하는데 이때, 이 조각을 패킷

### 17. TCP와 UDP의 차이점은?

- UDP(User Datagram Protocol) : 데이터를 데이터그램(독립적인 관계를 지니는 패킷) 단위로 처리하는 프로토콜

<img src="https://images.velog.io/images/daon9apples/post/f4f756e7-c6f5-41bd-8467-e381517be404/image.png" width="600">

### 18. 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가?

- 브라우저 주소창에 maps.google.com을 입력한다.
- 브라우저가 maps.google.com의 IP 주소를 찾기 위해 캐시에서 DNS 기록을 확인한다.
- 만약 요청한 URL(maps.google.com)이 캐시에 없다면, ISP의 DNS 서버가 DNS 쿼리로 maps.google.com을 호스팅하는 서버의 IP 주소를 - 찾는다.
- 브라우저가 해당 서버와 TCP 연결을 시작한다.
- 브라우저가 웹서버에 HTTP 요청을 보낸다.
- 서버가 요청을 처리하고 응답을 보낸다.
- 서버가 HTTP 응답을 보낸다.
- 브라우저가 HTML 컨텐츠를 보여준다.

### 19. JavaScript Event Loop

> 자바스크립트 엔진은 실행될 코드를 콜스텍으로 할당해서 실행하게 됩니다. 동기적인 코드가 먼저 실행이 되는데요. 그 동안 비동기 코드들 같은 경우에는 웹 API의 처리를 거치게 됩니다.
> 그리고 콜백 큐에 담아집니다. 그리고 동기 함수의 처리가 끝나고 비동기 함수가 처리 될때 이벤트 루프는 콜백큐에 할당된 함수들을 순서에 맞춰 콜스텍에 할당해주고 실행됩니다.

<img src="https://github.com/YooJinRa/til/blob/main/Javascript/ExecutionContextMySelf.jpeg" width="800">

### 20. RESTFul API란?

- RESTful은 REST의 설계 규칙을 잘 지켜서 설계된 API를 RESTful한 API
  - REST API : REST의 특징을 기반으로 서비스 API를 구현한 것
  - 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능한 것
  - URI는 정보의 자원을 표현 / 자원에 대한 행위는 HTTP Method(GET, POST, PUT, PATCH, DELETE)로 표현 / 행위(Method)는 URI에 포함하지 않음

### 21. GET, POST 방식의 차이점

- GET, POST 방식 모두 브라우저가 서버에 요청하는 것
- GET, POST 방식 차이점
  - GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트 할 때 사용
  - GET 은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없으나, POST 는 body 에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재
  - GET 요청은 멱등이며, POST는 멱등이 아님
    - _멱등성 : 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질_

### 22. Webpack 써보신 적 있나요

- SPA(single page app)는 하나의 html에 수십, 수백 개의 자바스크립트 파일을 포함하기 때문에
- 자바스크립트는 태생이 브라우저에 종속적이었기 때문에 자체적인 모듈 시스템이 없었음
- 자바스크립트를 브라우저 밖에서 사용할 수 있게 하려는 노력 -> 대표적 CommonJS, AMD -> 자바스크립트를 범용적으로 사용하기 위해서 하는 대부분의 일은 모듈 시스템을 정의하는 일 -> nodejs 같은 프레임워크가 등장
- webpack은 CommonJS와 AMD 스펙 모두를 지원
- webpack을 사용하면 여러 개의 자바스크립트 파일을 하나의 파일(원한다면 여러 개)로 컴파일할 수 가능해짐
- 필요한 라이브러리를 npm으로 설치 후 필요한 부분에 import만 하면 바로 사용 가능

### 23. TCP와 UDP의 차이점

### 24. 동기와 비동기의 차이

- 동기 방식은 서버에서 요청을 보냈을 때 응답이 돌아와야 다음 동작을 수행 가능
- 비동기 방식은 반대로 요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행 할 수 있음

### 25. Array vs LinkedList

- Array 의 element 들은, 인접한 memory 위치에 저장 / Memory 는 Array 가 선언되자 마자 Compile time 에 할당
- LinkedList 의 element 들은, memory 어딘가에 저장 / Memory 는 새로운 node 가 추가될 때 runtime 에 할당

- 데이터 접근이 주 업무일 경우 → Array / 데이터 수정이 주 업무일 경우 → Linked List

### 26. 서버 사이드 렌더링이란?

- 서버에서 페이지를 그려 클라이언트(브라우저)로 보낸 후 화면에 표시하는 기법

### 27. MVC 패턴이란 무엇인가?

- MVC 는 Model, View, Controller의 약자
- 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴

### 28. 아토믹 디자인 패턴에 대해 아는가?

- 가장 작은 컨포넌트 단위를 원자로 설정하고 이를 바탕으로 상위 컴포넌트를 만들어 코드 재사용을 최대화하는 방법론
- 원자 -> 분자 -> 유기체 -> 템플릿 -> 페이지

### 29. 웹 스토리지의 차이점

- 웹 스토리지

  - 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 추가된 저장소
  - 간단한 Key-Value 스토리지 형태
  - 쿠키와 달리 자동 전송의 위험성이 없음
  - 오리진(Origin)(도메인,프로토콜,포트) 단위로 접근이 제한되는 특성 덕분에 CSRF로 부터 안전
  - 쿠키보다 큰 저쟝 용량 지원(모바일 2.5MB, 데스크탑 5~10MB)
  - 서버가 HTTP 헤더를 통해 스토리지 객체를 조작할 수 없음(웹 스토리지 객체 조작은 JavaScript 내에서만 수행)
  - 오직 문자형(string) 데이터 타입만 지원
  - 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage)가 있으며, 같은 Storage 객체를 상속하기 때문에 메서드가 동일

- 로컬 스토리지(localStorage)

  - 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 종료해도 계속 브라우저에 남아있음 (영구성) / 단, 동일한 브라우저를 사용할 때만 해당
  - 지속적으로 필요한 데이터 저장(자동 로그인 등)

- 세션 스토리지(sessionStorage)
  - 데이터가 오리진 뿐만 아니라 브라우저 탭에도 종속되기 때문에, 윈도우나 브라우저 탭을 닫을 경우 제거
  - 일시적으로 필요한 데이터 저장(일회성 로그인 정보, 입력폼 저장 등)

### 30. http vs https 차이점에 대해 설명해주세요

- SSL 인증서
  - SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화
- TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지함
  - TSL은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공

### 31. 웹 프로토콜이란?

- 웹에서 쓰이는 통신규약
  - protocol : 문서에 접근하기 위해 사용하는 프로토콜 이름
  - computer_name : 문서가 있는 컴퓨터(서버)의 도메인 이름
  - port : 서버가 어떤 포트 숫자를 바라보고 있는지 (선택)
  - document_name : 서버 컴퓨터에 있는 특정 문서의 이름
  - parameters: 페이지에 넘기는 변수 (선택)

### 32. AJAX란 무엇인가

- Asynchronous JavaScript and XML의 약자
- 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법의 하나
- Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있음. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시 가능

### 33. Promise와 Callback의 차이점은

- callback을 사용하면 비동기 로직의 결과값을 처리하기 위해서는 callback안에서만 처리를 해야하고, 콜백 밖에서는 비동기에서 온 값을 알 수가 없음
- 하지만 promise를 사용하면 비동기에에서 온 값이 promise 객체에 저장되기 때문에 코드 작성이 용이

### 34. 자바스크립트와 타언어의 차이점

- 자바스크립트는 동적 프로토 타입 기반 객체 지향언어(java와 다르게 클래스 개념이 없음)
- 자바스크립트는 싱글스레드기반 비동기처리

### 35. ES6의 호환성 해결방법은?

- 브라우저 별로 구동원리 또는 JS엔진 등의 차이가 있기 때문에 브라우저 호환성 이슈가 발생하는데,
- 이러한 차이를 최소화해 런타임 환경에 맞게 최적화 하는 작업을 크로스 브라우징이라고 하는데,
- Javascript의 호환성에 따른 충돌이나 부작용을 줄이기 위한 방법으로는 Babel이라는 도구를 사용하면 됨
- 바벨은 주로 ES5 이상 버전의 코드를 현재 및 과거의 브라우저와 같은 환경에서 호환되는 버전으로 변환하는데 사용되는 도구로, IE나 다른 브라우저에서 동일한 기능을 제공하고 side-effect를 최소한으로 줄일수 있음

### 36. babel은 컴파일러 인가 ? 트랜스파일러인가?

- JavaScript 트랜스컴파일러
- 트랜스파일러란 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른언어로 변환하는 것을 의미
- 컴파일은 한 언어로 작성된 코드를 다른 언어로 변환하는 것
- React는 일반적으로 JSX라는 특수한 문법을 사용하여 코딩을 하기 때문에 개발자가 작성한 원본 코드는 브라우저에서 제대로 실행이 되지 않음 -> 따라서 보통 Webpack 번들러와 Babel 로더를 이용하여 React 프로젝트를 빌드

### 37. ES6에 추가된 것은 무엇인가?

- String Literal, 객체 비구조화 ( Object Destructuring ), 객체 리터럴 ( Object Literal ), for .. of, Spread Operator, Rest Parameter, Arrow Function, Default Params, includes, Trailing Commas, Map & Set

### 38. Context API란?

- 컴포넌트를 건너띄고 다른 컴포넌트에서 state, function을 사용할 수 있음
- redux의 많은 어려운 개념보다 context api는 Provider, Consumer, createContext 개념만 알면 적용가능
- context는 컴포넌트안에서 전역적으로 데이터를 공유하도록 나온 개념
  - 로그인 데이터, 웹 내 사용자가 쓰는 설정파일, 테마, 언어 등 다양하게 컴포넌트간 공유되어야할 데이터로 사용

### 39. 라이프사이클 메소드에 대해 설명

- render() : 컨포넌트 모양새 정의 / 라이프사이클 메서드 중 유일 필수 메소드 / this.props와 this.state에 접근하며, 리액트 요소(태그 또는 컴포넌트)를 반환
- constructor(props){...} : 컨포넌트 생성자 메소드, 컨포넌트를 만들때 처음으로 실행 / 초기 state 정의 가능
- getDerivedStateFromProps 메소드 : props로 받아 온 값을 state에 동기화시키는 용도 / 컴포넌트가 마운트/업데이트 될 때 사용
- componentDidMount() {...} : 컴포넌트를 만들고 첫 렌더링을 마친 후 실행 / 비동기 작업을 처리
- shouldComponentUpdate(nextProps, nextState) {...} : props나 state를 변경했을 때, 리렌더링을 시작할지 여부를 지정하는 메서드 / 반드시 true/false 값을 반환 / 현재 props/state는 this.props와 this.state로 접근, 새로 설정될 props/state는 nextProps와 nextState로 접근
- getSnapshotBeforeUpdate : render에서 만들어진 결과물이 브라우저에 실제로 반영되기 직전에 호출 / 업데이트하기 직전 값을 참고할 때 사용(eg. 스크롤바 위치 유지)
- componentDidUpdate(prevProps, prevState, snapshot) {...} : 리렌더링 완료 후 실행 / DOM 관련 처리를 해도 괜찮음(업데이트가 끝난 직후이기 때문) / prevProps/prevState를 사용해 컴포넌트가 이전에 가졌던 데이터에 접근 가능 / getSnapshotBeforeUpdate의 반환값을 snapshot 파라미터로 사용 가능
- componentWillUnmout(){...} : 컴포넌트를 DOM에서 제거할 때 실행 / componentDidMount에서 등록한 이벤트, 타이머, 직접 생성한 DOM은 여기서 제거작업을 해야 함
- componentDidCatch : 컴포넌트 렌더링 도중 에러가 발생했을 때 애플리케이션이 먹통이 되지 않고 오류 UI를 보여주게 해줌

### 40. react 클래스형과 함수형의 차이

- 클래스형
  - state, LifeCycle Api 사용 가능
  - 임의의 메서드 정의 가능
- 함수형
  - state, LifeCycle Api 사용 불가(16.8 이후 제공되는 hook으로 해결가능)
  - 선언하기 클래스형 보다 편리
  - 메모리 자원을 클래스형보다 덜 사용
  - 빌드한 결과물의 크기가 클래스형보다 작음

### 41. 타입스크립트란?

- 자바스크립트의 경우는 동적 타입 언어(dynamic type language)이기 때문에 런타임 속도는 빠르지만 타입 안정성이 보장되지 않음
- 타입스크립트는 자바스크립트의 이러한 단점을 보완하기 위해서 만들어 짐 -> 이러한 이유로 MS에서는 타입스크립트에 “JavaScript that scales(확장된 자바스크립트)”라는 슬로건을 만듬
- 타입스크립트는 정적 타입 언어(static type language)이기 때문에 컴파일 시 시간이 조금 걸리더라도 안정성을 보장한다는 점이 장점

### 42. Angular와 React의 차이점

- 앵귤러 : 타입스크립트 기반 프레임워크 / 양방향 바인딩 지원 / Incremental DOM / Component 와 Service 단의 분리
- 리액트 : 자바스크립트 라이브러리 / Virtual DOM

### 43. SEO란?

- SEO(검색 엔진 최적화)는 웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정
  - 검색 엔진은 웹을 크롤링 (en-US)하면서 페이지에서 페이지로 링크를 따라가고, 찾은 콘텐츠의 색인(검색 결과에 보이는 것)을 생성
  - 크롤러는 일정 규칙을 따르므로, SEO를 진행하며 해당 규칙을 밀접하게 따라가면 웹사이트가 검색 결과의 보다 높은 곳에 노출돼 (전자상거래와 광고라면) 수익으로 연결될 수도 있음

### 44. 이벤트 위임이란?

- 이벤트 위임은 캡쳐링과 버블링을 이용한 것으로, 여러 엘리먼트마다 각각 이벤트 핸들러를 할당하지 않고, 공통되는 부모에 이벤트 핸들러를 할당하여 이벤트를 관리하는 방식

### 45. 메모이제이션이란?

- 메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술
- 리액트 메모이제이션 하는 이유
  - 비싼 연산을 반복하는 것을 피하여 성능을 향상
  - 안정된 값 제공

### 46. 이벤트 버블링이란

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작

### 47. 부모에서 자식으로 이벤트상속방법

- 이벤트 캡처링으로 부모에서 자식으로 이벤트를 상속 가능
- 이벤트 캡처링은 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하며 이벤트를 전파하는 방식 (부모 -> 자식)

### 48. 이벤트버블링을 막는 방법

- 이벤트 객체의 메서드인 event.stopPropagation()를 사용
- 버블링을 멈추고, 요소에 할당된 다른 핸들러의 동작도 막으려면 event.stopImmediatePropagation()을 사용 -> 이 메서드를 사용하면 요소에 할당된 특정 이벤트를 처리하는 핸들러 모두가 동작하지 않음
- 핸들러의 event 객체에 데이터를 저장해 다른 핸들러에서 읽을 수 있게 하면, 아래쪽에서 무슨 일이 일어나는지를 부모 요소의 핸들러에게 전달할 수 있으므로, 이 방법으로도 이벤트 버블링을 통제 가능

### 49. 이벤트버블링 활용 방법

- 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식으로 이벤트 버블링을 활용(이벤트 위임)
- 이벤트 버블링을 응용하여 부모 엘리먼트에 리스너를 위임하여 부착하면, 리스너의 개수를 1개로 줄여 최적화 가능

### 50. React, 왜 사용하시나요?

- SPA
- React Native 앱 개발 가능
- 수 많은 커뮤니티
- 컨포넌트 재사용 가능(유지보수 용이)

### CI/CD

> CI는 지속적 통합이란 뜻을 가지고 있으며, 코드 변경을 수시로 구현하고 레파지토리에 체크인 해서 코드를 병합 하는 것 의미합니다.
> 그리고 CD는 지속적 제공, 지속적 배포라는 의미를 가지고 지속적 통합이 끝나는 시점부터 시작되며, 빌드와 테스트를 거쳐서 저장소에 업로드 하고 사용자가 사용할 수 있는 배포환경까지 릴리즈 하는 것을 의미합니다.

### about

> 프로젝트를 진행하면서 많은 오류를 마주하게 되었습니다.
> 오류를 마주하고 해결하는 것이 즐거운 프론트엔드 개발자 나유진입니다.
> 저는 스스로의 부족한 점을 채우기 위해 노력하면서 나아가 그 지식을 동료들과 공유하는 것이 좋습니다.
> 프로젝트가 끝나고 코드의 전체적인 흐름에 대해서 같이 한 동료들이 질문을 했었습니다.
> 오랜시간 코드에 대한 내용을 공유하면서, 설명했던 기억이 있습니다. 그 이후에 동료들이 잘 적용하는 모습을 보고 성취감을 느꼈었습니다.

### 정리 필요

- react 특징
- ssl인증서에 대한 설명
- get post put delete http method
- react hooks
- nextjs에 대한 내용
- javascript array methods
- 상태관리
- useState에 대한 내용
- 공식문서 읽어보기

### 리액트란?

> - 리액트는 UI 자바스크립트 라이브러리로서 싱글페이지 어플리케이션의 UI를 생성하는데 집중한 라이브러리입니다. 리액트는 자바스크립트에 HTML을 포함하는 JSX 문법과 단방향 데이터 바인딩을 사용하고 있습니다. 그리고 가상돔이라는 개념을 사용하여 웹 어플리케이션의 퍼포먼스를 최적화한 라이브러리입니다.

### 리액트의 특징

> ### 가상돔( 웹 애플리케이션의 성능을 극대화 )
>
> - 리액트는 리플로우와 리페인트가 자주 수행되는 문제를 해결하기 위해 화면에 표시되는 DOM과 동일한 DOM을 메모리상에 만들고 DOM 조작이 발생하면 메모리상에 생성한 가상 돔에 모든 연산을 수행한 후, 실제 DOM을 갱신하여 리플로우/리페인트의 연산을 최소화했습니다.
>
> ### 단방향 데이터 바인딩
>
> - 단방향 데이터 바인딩은 단 하나의 Watcher가 자바스크립트의 데이터 갱신을 감지하여 사용자의 UI 데이터를 갱신합니다. 사용자가 UI를 통해 자바스크립트의 데이터를 갱신할 때는, 이벤트를 통해 갱신하게 됩니다. 이처럼 단방향 데이터 바인딩은 하나의 Watcher를 사용하기 때문에 양방향 데이터 바인딩이 가지는 성능적인 이슈를 해결하고 더 확실하게 데이터를 추적할 수 있게 해줍니다. (양방향 데이터 바인딩은 하나에 데이터 동기화에 두 개의 Watcher가 사용되고, 데이터 많아지게 되면 이 데이터의 동기화를 위한 수많은 Watcher가 생성되므로, 반대로 성능 저하가 발생할 수 있습니다.)
>
> ### JSX
>
> - JSX는 자바스크립트와 HTML을 동시에 사용하며, HTML에 자바스크립트의 변수들을 바로 사용할 수 있는 일종의 템플릿 언어(Template language)입니다.
>
> ### 선언형 프로그래밍
>
> - 프로그래밍에는 명령형 프로그래밍과 선언형 프로그래밍으로 구별할 수 있습니다. 명령형 프로그래밍은 프로그래밍을 할 때 어떻게(How)에 집중하는 것을 말하며 선언형 프로그래밍은 무엇(What)에 집중하여 프로그래밍을 하는 것을 말합니다.
> - 라이브러리나 프레임워크 등을 사용하여 비선언형적인 부분을 캡슐화함으로써 명령형 프로그래밍 언어로 선언형 프로그래밍을 할 수 있습니다. 리액트에서는 특히 JSX를 사용하기 때문에 선언형 프로그래밍을 더욱 활용하고 있음을 알 수 있습니다.
>
> ### 컨포넌트 기반
>
> - 컴포넌트는 재사용을 할 수 있으며 이런 재사용을 통해 개발 생산성을 향상시킬 수 있습니다. 또한 이렇게 작고 고립된 컴포넌트는 테스트하기 쉬워 코드를 유지보수하는데도 크게 도움이 됩니다.

### 반응형 웹 vs 적응형 웹

> - 반응형웹은 모든 디바이스에서 하나의 템플릿이 적용되기 때문에 모든 콘텐츠를 다운받고 현재 해상도에 맞는 화면이 랜딩 ➡️ 로딩 속도가 느려질 수 있습니다. 반면에 적응형 웹은 서비스를 제공하고자하는 여러 디바이스에 적합한 독립적인 템플릿이 존재하며, 감지된 디바이스에 맞는 필요한 콘텐츠만 다운받고 랜딩 ➡️ 필요한 콘텐츠만 다운받으니 로딩속도가 보다 빠릅니다.

### null vs undefined

> - undefined은 변수를 선언하고 값을 할당하지 않은 상태, null은 변수를 선언하고 빈 값을 할당한 상태(빈 객체)입니다. 즉, undefined는 자료형이 없는 상태를 말합니다.

### Amazon CloudFront

- CDN 서비스(Contents Delivery Network 데이터 사용량이 많은 애플리케이션의 웹 페이지 로드 속도를 높이는 상호 연결된 서버 네트워크)

#### **CloudFront**

> 대기 시간을 줄이거나 네트워크 설계로 인해 발생하는 통신 지연을 줄이는 것!<br>
> CDN 서비스로 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원하는 웹 서비스입니다. CloudFront는 엣지로케이션이라고 하는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다. 콘텐츠를 사용자가 요청하면 지연시간이 가장 낮은 엣지로케이션으로 요청이 라우팅 되므로 가능한 최고의 성능으로 콘텐츠가 제공됩니다.

- Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원하는 웹 서비스입니다. CloudFront는 엣지 로케이션이라고 하는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다. CloudFront를 통해 서비스하는 콘텐츠를 사용자가 요청하면 지연 시간이 가장 낮은 엣지 로케이션으로 요청이 라우팅되므로 가능한 최고의 성능으로 콘텐츠가 제공됩니다.
  - 콘텐츠가 이미 지연 시간이 가장 낮은 엣지 로케이션에 있는 경우 CloudFront가 콘텐츠를 즉시 제공합니다.
  - 콘텐츠가 엣지 로케이션에 없는 경우 CloudFront는 콘텐츠의 최종 버전에 대한 소스로 지정된 오리진(Amazon S3 버킷, MediaPackage 채널, HTTP 서버(예: 웹 서버) 등)에서 콘텐츠를 검색합니다.

### Amazon S3

- 객체 스토리지 서비스

### 자기소개

> 안녕하세요. 7:3 프론트엔드 개발자 나유진입니다. 하루에 커피를 3잔씩 마시며 노력하는 모습을 보고, 제 몸에 있는 수분은 커피 7 : 물 3의 비율로 있다고 동료가 붙여준 별명입니다. 커피를 마시며, 제 코딩을 향한 열정, 배움을 향한 열정을 불태우는 것을 좋아합니다. 동시에 3의 인풋을 통해 7의 아웃풋 내기 위해 노력하는 것이 즐거운 개발자입니다.
