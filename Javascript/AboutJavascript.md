# Javascript 언어의 특성
-----

# 1. Javascript 자료형

- 자바스크립트의 모든 값은 데이터 타입을 가짐
- _primitive type(원시타입)_ 과 _object/reference type(객체타입)_ 으로 분류

## 1) primitive type(변경 불가능)
> - 📌 숫자타입 number : 숫자, 정수와 실수 구분없이 하나의 숫자 타입만 존재 <br />
> - 📌 BigInt 타입 : BigInt 타입은 임의 정밀도로 정수를 나타낼 수 있는 JavaScript 숫자 원시 값. BigInt를 Number의 안전 한계를 넘어서는 큰 정수도 안전하게 저장하고 연산
> - 📌 문자열 타입 string : 문자열 <br />
> - 📌 불리언 타입 boolean : 논리적 참 true과 거짓 false <br />
> - 📌 undefined 타입 : var 키워드로 선언된 변수에 암묵적으로 할당되는 값 <br />
> - 📌 null 타입 : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 <br />
> - 📌 심벌 타입 symbol : ES6에서 추가된 7번쨰 타입, 다른 값과 절대 중복되지 않는 유일무이한 값

## 2) reference type(변경 가능)
> - 📌 객체 : 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조<br />
> - 📌 함수 : 일렬의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의한 것<br />
> - 📌 배열 : 여러 개의 값을 순차적으로 나열한 자료구조 <br />

-----

# 2. JavaScript만의 특성

## 1) 느슨한 타입(loosely typed)의 동적(dynamic)언어
- 📌 **동적타입의 언어** : 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있음
> - cf) 정적타입의 언어 : 변수 선언 시점에 변수ㅠ의 타입이 결정되고 변수의 타입을 변경할 수 없음

> ### 가. 문제점<br />
>   - 변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있음 <br />
>   - 또한 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있음<br />
>   - 동적타입 언어 변수는 값을 확인하기 전에는 타입을 확신할 수 없음 <br />
<br />

> ### 나. 보완 방법<br />
>   - 변수는 꼭 필요한 경우에 제한적으로 사용
>   - 변수의 유효범위(스코프) 는 최대한 좁게 만들어 변수의 부작용을 억제
>   - 전역변수는 최대한 사용하지 않도록 함
>   - 변수보다는 상수를 사용해 값의 변경을 억제(const) 


## 2) JavaScript 형변환
- 자바스크립트는 타입이 매우 유연한 언어
- 📌 **암시적변환** : 자바스크립트 엔진이 필요에 따라 자동으로 데이터타입을 변환시키는 것
- 📌 **명시적변환** : 개발자의 의도에 따라 형변환

### 가. 암시적변환
- 📌 산술연산자 (+) : 연산자는 숫자보다 문자열이 우선시 되기때문에, 숫자형이 문자형을 만나면 문자형으로 변환하여 연산 (문자 > 숫자)
```
number + number // number
number + string // string
string + string // string
string + boolean // string
number + boolean // number
```

- 📌 다른 연산자(-,*,/,%) : 숫자형이 문자형보다 우선시되기 때문에 더하기와 같은 문자형으로의 변환이 일어나지 않음 (문자 < 숫자)
```
string * number // number
string * string // number
number * number // number
string * boolean // number
number * boolean // number
```

- 📌 동등 비교 : 엄격하지 않은 동등(==) 비교
```
null == undefined // true
“0” == 0 // true
0 == false // true
“0” == false // true
```

### 나. 명시적 변환
- A Type → Number Type
```
Number()
parseInt()
parseFloat()
```

- A Type → String Type
```
String()
toString()
toFixed()
```

- A Type → Boolean Type
```
Boolean()
```

## 3) ==(동등비교), ===(일치비교)
| 비교연산자 | 의미 | 사례 | 설명 |
|-----|-----|-----|-----|
| == | 동등비교 | x==y | x와 y의 값이 같음 |
| === | 일치비교 | x===y | x와 y의 값과 타입이 같음 |


## 4) undefined와 null의 미세한 차이
- 📌 null : 사용자가 값이 없다고 정의한 값
- 📌 undifined : 컴퓨터가 빈 값이라고 알려주는 초기화 값

-----

# 3. JavaScript 객체와 불변성

## 1) 원시타입과 객체타입의 차이점

| 원시 타입 | 객체타입 |
|-----|-----|
| 원시 타입의 값, 즉 원시값은 변경 불가능한 값 | 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값 |
| 원시 값을 변수에 할당하면 변수에는 실제값이 저장 | 객체를 변수에 할당하면 변수에는 참조 값이 저장 |
| 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달(값에 의한 전달) | 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달(참조에 의한 전달)|


## 2) 불변 객체와 불변객체를 만드는 방법
- 📌 불변 객체 Immutable Object : 객체 내부 프로퍼티를 변경할 때마다 새로운 객체를 만들어 재할당하기로 정하거나 자동으로 새로운 객체를 만드는 도구를 활용하여 불변성 확보
- 불변 객체가 필요한 경우 : 객체에 변화를 가해도 원본이 그대로 남아있어야 하는 경우
- 불변객체를 만드는 방법 : `const` / `Object.freeze()`


## 3) ⭐ 얕은 복사와  ⭐ 깊은 복사
- 📌 객체를 프로퍼티 값으로 갖는 객체의 경우 **얕은 복사** 는 한 단계까지만 복사하는 것을 말함
- 📌 **깊은 복사** 는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말함
- 얉은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체
- 원본과 복사본은 참조 값이 다른 별개의 객체
- 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전 복사본을 만든다는 차이가 있음

----

# 4. ⭐⭐⭐ 호이스팅과 TDZ
- 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끓어 올리고(호이스팅), 외부환경정보를 구성하고, this 값을 설정하는 등의 동작을 수행

## 1) 실행컨텍스트
### 가. 내가 이해한 실행 컨텍스트
<img src="https://github.com/YooJinRa/til/blob/main/Javascript/ExecutionContextMySelf.jpeg" width="800">

- 📌 자바스크립트 엔진에는 Memory Heap과 Call Stack이 있음
- 📌 Memory Heap : 메모리 할당이 일어나는 곳
- 📌 Call Stack : 실행될 코드의 한 줄 단위로 할당 되는 곳
- 📌 Web API : 비동기 처리를 담당
- 📌 Callback Queue : 비동기 처리가 끝난 후 실행되어야 할 콜백함수가 차례로 할당
- 📌 Queue : 데이터를 넣을 수 있는 선형 자료형
- 📌 Event Loop : Queue에 할당된 함수를 순서에 맞춰 콜스텍에 할당


### 나. 실행컨텍스트 정의
- 📌 실행컨텍스트 Execution context : 실행할 코드에 제공할 환경 정보를 모아놓은 객체
- 동일한 환경에 있는 코드들을 실행할 때 필요한 환경정보들을 모아 컨텍스트를 구성하고 이를 콜스텍에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장
```
// ------------------------ (1)
var a = 1;
function outer() {
   function inner() {
      console.log(a);
      var a = 3;
      // ------------------ (2)
   }
   inner(); // ------------ (3)
   console.log(a);
   // --------------------- (4)
}
outer(); // --------------- (5)
console.log(a);
// ------------------------ (6)
```

<img src="https://github.com/YooJinRa/til/blob/main/Javascript/ExecutionContext.png" width="500">
_ * 이미지 출처 : <https://medium.com/crocusenergy/js-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-2b8ab8da4f4>

## 2) 스코프와 스코프 체인

### 가. 스코프
- 📌 식별자에 대한 유효 범위
- 📌 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정되는데 이를 스코프라고 함

>  - 어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근 가능하지만, A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근 가능 (쥐구멍...)

- 스코프의 종류
| 구분 | 설명 | 스코프 | 변수 |
|-----|-----|-----|-----|
| 전역 global | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 local | 함수 몸체 내부 | 지역 스코프 | 지역 변수 |

   - 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수


### 나. 스코프 체인
- 📌 스코프가 함수의 중첩에 의해 계층적으로 구조를 가짐
- 📌 식별자의 유효범위 안에서부터 바깥으로 차례로 검색해 나가는 것
- 📌 현재 scope, 컨텍스트에서 식별자를 찾을 수 없는 경우 outerEnvironmentReference를 통해 상위 스코프, 컨텍스트에서 식별자를 찾아 가는 방식

> - 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색함

- 📌 변수 은닉화 variable shadowing : inner함수에서 a 변수를 선언함으로써 전역 공간의 a 변수 접근을 막음
> - 스코프 체이닝의 특성을 이용해, 자식 컨텍스트에 전역 변수 명과 동일한 변수를 선언함으로써 전역 변수 접근을 막는 방식

```
var name = 'a';

function a(){
	console.log(name);
}
function b(){
	name = 'b';
	a();
}
b();
```


## 3) 호이스팅 Hoisting
- 📌 함수가 실행되기 전에 JS 엔진이 안에 있는 변수를 범위의 최상단으로 끌어 올리는 것

### 가. 함수 호이스팅
- 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태
- 함수 선언문 이전에 함수를 참조할 수 있으며, 호출할 수도 있음
- **함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 _함수호이스팅_ 이라 함**

### 나. ⭐⭐⭐ 함수 호이스팅과 변수 호이스팅의 공통점과 차이점
- var 키워드를 사용한 변수 선언문과 함께 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일
- var 키워드로 선언된 변수는 undefined로 초기화 / 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화
- var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만, 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출 가능
> - 참고) 변수 선언은 런타임 이전에 실행되어 undefined로 초기화 되지만 변수 할당문의 값은 할당문이 실행되는 시점(런타임)에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨
> - 함수표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생

## 4) var, let, const
- 📌 var : 함수만 지역변수로 선언되고, 나머지는 다 전역변수로 올림 / 중복된 변수명을 사용해도 실행가능 / 값 변경(재할당) 가능 / 변수 호이스팅 가능 / 블록에 선언되었다고 해도 해당 함수 안을 어디든 돌아 다닐 수 있음
> - var는 코드를 매우 헷갈리게 만든다. 코드가 직관적이지 않고, window.변수명으로 실행가능.

- 📌 let : 값 변경(재할당) 가능 / 지역변수로 선언 / 중복으로 변수명을 사용할 수 없음(재 선언을 할 수 없음) / TDZ Temproral Death Zone(일시적으로 죽은 공간을 만들어줌) -> 변수의 선언문이 나오기 전까지 사전에 실행 할 수 없음 / 블록레벨 스코프 : 블록 내에서만 사용 가능
```
console.log(a);
let a = 1;
console.log(a);

// ReferenceError~~
```

- 📌 const : 선언시 값을 넣어줘야 하고, 한 번 넣은 값은 바꿀 수 없음 / TDZ Temproral Death Zone(일시적으로 죽은 공간을 만들어줌) -> 변수의 선언문이 나오기 전까지 사전에 실행 할 수 없음 / 블록레벨 스코프 : 블록 내에서만 사용 가능
<br />

-----
### 추가로! 코딩할 때 유의!
> - 변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다.
> - 재할당이 필요한 경우에 한정해 let을 사용하고 이 때 변수의 스코프는 최대한 좁게 만든다.
> - 선언을 가장 위에다 쓰자. 선언하기 전에 접근을 하지 말자. 애초에 호이스팅을 만들 상황을 아예 만들지 말자. === 코딩 잘하는 방법

-----

### 문제
```
let b = 1;
function hi () {
   const a = 1;
   let b = 100;
   b++;
   console.log(a,b);
}
// console.log(a); // 오류 이유 : const는 블록레벨 스코프이기 때문에 블록 내에서만 사용가능
console.log(b); // 1
hi(); // 1 101
console.log(b); // 1
```