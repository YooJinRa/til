# 화살표 함수 arrow function
- 화살표 함수 arrow function 는 function 키워드 대신 화살표 => 를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있음
- 표현만 간략한 것이 아니라 내부 동작도 기존 함수보다 간략
- 화살표 함수는 콜백함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대한으로 유용

## 1. 화살표 함수 정의 문법
- 화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식(값으로 평가될 수 있는 문)으로 정의

### 1) 매개변수 선언
> - 매개변수가 여러 개인 경우 소괄호() 안에 매개변수를 선언 `const arrow = (x, y) => x * y;` <br />
> - 매개변수가 한 개인 경우 소괄호()를 생략 할 수 있음 `const arrow = x => { ... }` <br />
> - 매개변수가 없는 경우 소괄호()를 생략 할 수 없음 `const arrow = () => { ... }` <br />

### 2) 함수 몸체 정의 
> - 함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {}를 생략할 수 있음 
>> `const power = x => x ** 2;`<br />
> - 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환됨
>> `const power = x => { return x ** 2 };`<br />
> - 함수 몸체를 감싸는 중괄호{}를 생략한 경우 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생함 :::: 표현식이 아닌 문은 반환할 수 없기 때문
>> `const arrow = () => const x = 1; // SyntaxError` <br />
>> `const arrow = () => { return const x = 1; }` <br />
> - 함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호를 생략할 수 없음 <br />
> - 객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호()로 감싸주어야 함 :::: 객체 리터럴을 소괄호로 감싸지 않으면 객체 리터럴의 중괄호{}를 함수 모체를 감싸는 중괄호{}로 잘못 해석 됨<br />
>> `const create = (id, content) => ({ id, content })`<br />
> - 함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호를 생략할 수 없음, 이때 반환값이 있다면 명시적으로 반환해야 함<br />
> - 화살표 함수도 즉시 실행 함수고 사용할 수 있음<br />
> - 화살표 함수도 일급객체이므로 고차 함수에 인수로 전달할 수 있음<br />
> - 콜백함수로 정의할 때 유용<br />

## 2. 화살표 함수 vs 일반 함수
- 화살표 함수는 인스턴스를 생성할 수 없는 non-structor :::: prototype 프로퍼티가 없고 프로토타입도 생성하지 않음
- 중복된 매개변수 이름을 선언할 수 없음
- 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않음(??????아직 이해 못함....????)